<!DOCTYPE html><html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Raster-Prototyp mit A* und Suchbegrenzung</title>
  <style>
    body { background: #111; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
    h1 { margin-top: 20px; }
    #grid {
      display: grid;
      grid-template-columns: repeat(32, 20px);
      grid-template-rows: repeat(32, 20px);
      gap: 1px;
      margin: 20px;
    }
    .cell {
      width: 20px;
      height: 20px;
      background-color: #2c2c2c;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
    }
    .player { background-color: limegreen; }
    .enemy { background-color: crimson; }
    .wall { background-color: #555; pointer-events: none; }
    .empty { background-color: #2c2c2c; }
  </style>
</head>
<body>
  <h1>🧠 Stärke Merge Battle – Begrenzte Wegsuche</h1>
  <p>Spielerstärke: <span id="playerLevel">1</span></p>
  <div id="grid"></div>
  <p id="message"></p>  <script>
    const gridSize = 32;
    const searchLimit = 8; // maximale Reichweite
    const grid = document.getElementById('grid');
    const message = document.getElementById('message');
    const playerLevelDisplay = document.getElementById('playerLevel');

    let playerLevel = 1;
    let playerSpawn = { x: 1, y: 1 };
    let playerPosition = { ...playerSpawn };

    const enemies = [
      { x: 4, y: 1, level: 1, alive: true },
      { x: 6, y: 2, level: 2, alive: true },
      { x: 8, y: 3, level: 3, alive: true }
    ];

    const walls = [];
    for (let y = 1; y <= 8; y++) walls.push({ x: 3, y });
    for (let y = 10; y <= 20; y++) walls.push({ x: 15, y });

    function isWall(x, y) {
      return walls.some(w => w.x === x && w.y === y);
    }

    function createCell(x, y) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.x = x;
      cell.dataset.y = y;

      if (x === playerPosition.x && y === playerPosition.y) {
        cell.classList.add('player');
        cell.textContent = '🧍';
      } else {
        const enemy = enemies.find(e => e.x === x && e.y === y && e.alive);
        if (enemy) {
          cell.classList.add('enemy');
          cell.textContent = enemy.level;
          cell.addEventListener('click', () => moveTo(enemy));
        } else if (isWall(x, y)) {
          cell.classList.add('wall');
        } else {
          cell.classList.add('empty');
        }
      }

      return cell;
    }

    function renderGrid() {
      grid.innerHTML = '';
      playerLevelDisplay.textContent = playerLevel;
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          grid.appendChild(createCell(x, y));
        }
      }
    }

    function moveTo(enemy) {
      const dx = Math.abs(enemy.x - playerPosition.x);
      const dy = Math.abs(enemy.y - playerPosition.y);
      if (dx > searchLimit || dy > searchLimit) {
        message.textContent = 'Ziel liegt zu weit entfernt!';
        return;
      }
      const path = aStar(playerPosition, { x: enemy.x, y: enemy.y });
      if (!path) {
        message.textContent = 'Kein Weg zum Ziel!';
        return;
      }
      followPath(path, enemy);
    }

    function followPath(path, enemy) {
      if (path.length === 0) return;
      const next = path.shift();
      playerPosition = next;
      renderGrid();
      setTimeout(() => {
        if (path.length > 0) {
          followPath(path, enemy);
        } else {
          fightEnemy(enemy);
        }
      }, 100);
    }

    function fightEnemy(enemy) {
      if (playerLevel >= enemy.level) {
        playerLevel += enemy.level;
        enemy.alive = false;
        playerPosition = { x: enemy.x, y: enemy.y };
        message.textContent = `Gegner besiegt! Neue Stärke: ${playerLevel}`;
      } else {
        message.textContent = `Zu stark! Du verlierst und startest neu.`;
        resetGame();
        return;
      }
      renderGrid();
    }

    function resetGame() {
      playerLevel = 1;
      playerPosition = { ...playerSpawn };
      enemies.forEach(e => e.alive = true);
      renderGrid();
    }

    function aStar(start, goal) {
      const openSet = [start];
      const cameFrom = {};
      const gScore = {};
      const fScore = {};

      function key(pos) {
        return `${pos.x},${pos.y}`;
      }

      gScore[key(start)] = 0;
      fScore[key(start)] = heuristic(start, goal);

      while (openSet.length > 0) {
        openSet.sort((a, b) => fScore[key(a)] - fScore[key(b)]);
        const current = openSet.shift();

        if (current.x === goal.x && current.y === goal.y) {
          return reconstructPath(cameFrom, current);
        }

        const neighbors = [
          { x: current.x + 1, y: current.y },
          { x: current.x - 1, y: current.y },
          { x: current.x, y: current.y + 1 },
          { x: current.x, y: current.y - 1 }
        ];

        for (const neighbor of neighbors) {
          const dx = Math.abs(neighbor.x - playerPosition.x);
          const dy = Math.abs(neighbor.y - playerPosition.y);
          if (
            neighbor.x < 0 || neighbor.y < 0 ||
            neighbor.x >= gridSize || neighbor.y >= gridSize ||
            isWall(neighbor.x, neighbor.y) ||
            dx > searchLimit || dy > searchLimit
          ) continue;

          const tentativeG = gScore[key(current)] + 1;
          if (tentativeG < (gScore[key(neighbor)] || Infinity)) {
            cameFrom[key(neighbor)] = current;
            gScore[key(neighbor)] = tentativeG;
            fScore[key(neighbor)] = tentativeG + heuristic(neighbor, goal);
            if (!openSet.some(p => p.x === neighbor.x && p.y === neighbor.y)) {
              openSet.push(neighbor);
            }
          }
        }
      }
      return null;
    }

    function heuristic(pos1, pos2) {
      return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
    }

    function reconstructPath(cameFrom, current) {
      const path = [current];
      while (cameFrom[`${current.x},${current.y}`]) {
        current = cameFrom[`${current.x},${current.y}`];
        path.unshift(current);
      }
      return path.slice(1);
    }

    renderGrid();
  </script></body>
</html>
