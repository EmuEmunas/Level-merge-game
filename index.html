<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>St√§rke Merge Battle ‚Äì einfache Wegfindung</title>
  <style>
    body { background: #111; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
    h1 { margin-top: 20px; }
    #grid {
      display: grid;
      grid-template-columns: repeat(32, 20px);
      grid-template-rows: repeat(32, 20px);
      gap: 1px;
      margin: 20px;
    }
    .cell {
      width: 20px;
      height: 20px;
      background-color: #2c2c2c;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
    }
    .player { background-color: limegreen; }
    .enemy { background-color: crimson; }
    .wall { background-color: #555; pointer-events: none; }
    .empty { background-color: #2c2c2c; }
  </style>
</head>
<body>
  <h1>üß† St√§rke Merge Battle</h1>
  <p>Spielerst√§rke: <span id="playerLevel">1</span></p>
  <div id="grid"></div>
  <p id="message"></p>

  <script>
    const gridSize = 32;
    const grid = document.getElementById('grid');
    const message = document.getElementById('message');
    const playerLevelDisplay = document.getElementById('playerLevel');

    let playerLevel = 1;
    let playerSpawn = { x: 1, y: 1 };
    let playerPosition = { ...playerSpawn };

    const enemies = [
      { x: 4, y: 1, level: 1, alive: true },
      { x: 6, y: 2, level: 2, alive: true },
      { x: 8, y: 3, level: 3, alive: true }
    ];

    const walls = [];
    for (let y = 1; y <= 8; y++) walls.push({ x: 3, y });
    for (let y = 10; y <= 20; y++) walls.push({ x: 15, y });

    function isWall(x, y) {
      return walls.some(w => w.x === x && w.y === y);
    }

    function createCell(x, y) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.x = x;
      cell.dataset.y = y;

      if (x === playerPosition.x && y === playerPosition.y) {
        cell.classList.add('player');
        cell.textContent = 'üßç';
      } else {
        const enemy = enemies.find(e => e.x === x && e.y === y && e.alive);
        if (enemy) {
          cell.classList.add('enemy');
          cell.textContent = enemy.level;
          cell.addEventListener('click', () => walkTo(enemy));
        } else if (isWall(x, y)) {
          cell.classList.add('wall');
        } else {
          cell.classList.add('empty');
        }
      }

      return cell;
    }

    function renderGrid() {
      grid.innerHTML = '';
      playerLevelDisplay.textContent = playerLevel;
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          grid.appendChild(createCell(x, y));
        }
      }
    }

    function walkTo(enemy) {
      const path = simplePath(playerPosition, { x: enemy.x, y: enemy.y });
      if (!path) {
        message.textContent = 'Kein Weg zum Gegner!';
        return;
      }
      followPath(path, () => fightEnemy(enemy));
    }

    function followPath(path, onArrive) {
      if (path.length === 0) return onArrive();
      const next = path.shift();
      playerPosition = next;
      renderGrid();
      setTimeout(() => followPath(path, onArrive), 100);
    }

    function fightEnemy(enemy) {
      if (playerLevel >= enemy.level) {
        playerLevel += enemy.level;
        enemy.alive = false;
        playerPosition = { x: enemy.x, y: enemy.y };
        message.textContent = `Gegner besiegt! Neue St√§rke: ${playerLevel}`;
      } else {
        message.textContent = `Zu stark! Du verlierst und startest neu.`;
        resetGame();
      }
      renderGrid();
    }

    function simplePath(start, goal) {
      const visited = new Set();
      const queue = [{ ...start, path: [] }];
      while (queue.length) {
        const current = queue.shift();
        const key = `${current.x},${current.y}`;
        if (visited.has(key)) continue;
        visited.add(key);

        if (current.x === goal.x && current.y === goal.y) {
          return [...current.path, { x: current.x, y: current.y }].slice(1);
        }

        const directions = [
          { x: 1, y: 0 },
          { x: -1, y: 0 },
          { x: 0, y: 1 },
          { x: 0, y: -1 }
        ];

        for (const dir of directions) {
          const nx = current.x + dir.x;
          const ny = current.y + dir.y;
          if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize || isWall(nx, ny)) continue;
          queue.push({ x: nx, y: ny, path: [...current.path, { x: current.x, y: current.y }] });
        }
      }
      return null;
    }

    function resetGame() {
      playerLevel = 1;
      playerPosition = { ...playerSpawn };
      enemies.forEach(e => e.alive = true);
      renderGrid();
    }

    renderGrid();
  </script>
</body>
</html>
