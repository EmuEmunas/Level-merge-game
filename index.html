
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>St√§rke Merge Battle 3D</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #111; }
    canvas { width: 100%; height: 100%; display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      font-family: sans-serif;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="ui">üßç Spielerst√§rke: <span id="playerLevel">1</span></div>
  <canvas id="renderCanvas"></canvas>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const playerLevelDisplay = document.getElementById("playerLevel");

    const tileSize = 2;
    const gridSize = 10;
    let playerLevel = 1;
    let playerMesh, scene;
    const wallPositions = [{x:3,z:2},{x:3,z:3},{x:3,z:4},{x:5,z:5},{x:5,z:6},{x:5,z:7}];
    let enemyMeshes = [];

    const directions = [
      { dx: 1, dz: 0 }, { dx: -1, dz: 0 }, { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
    ];

    const enemyData = [
      { x: 4, z: 1, level: 1 },
      { x: 6, z: 2, level: 2 },
      { x: 8, z: 3, level: 3 }
    ];

    let playerStart = { x: 1, z: 1 };
    let playerGridPos = { ...playerStart };

    function posKey(x, z) {
      return `${x},${z}`;
    }

    function createScene() {
      scene = new BABYLON.Scene(engine);
      const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/2.5, 30, new BABYLON.Vector3(10, 0, 10), scene);
      camera.attachControl(canvas, true);
      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
      groundMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);

      const grid = {};
      for (let x = 0; x < gridSize; x++) {
        for (let z = 0; z < gridSize; z++) {
          const tile = BABYLON.MeshBuilder.CreateBox(`tile_${x}_${z}`, { size: tileSize, height: 0.1 }, scene);
          tile.position.set(x * tileSize, -0.05, z * tileSize);
          tile.material = groundMat;
          grid[posKey(x,z)] = true;
        }
      }

      wallPositions.forEach(w => {
        const wall = BABYLON.MeshBuilder.CreateBox("wall", { size: tileSize, height: 1 }, scene);
        wall.position.set(w.x * tileSize, 0.5, w.z * tileSize);
        grid[posKey(w.x, w.z)] = false;
      });

      playerMesh = BABYLON.MeshBuilder.CreateBox("player", { size: 1 }, scene);
      playerMesh.position.set(playerGridPos.x * tileSize, 0.5, playerGridPos.z * tileSize);

      const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

      enemyMeshes = enemyData.map((e, i) => {
        const mesh = BABYLON.MeshBuilder.CreateSphere("enemy" + i, { diameter: 1.4 }, scene);
        mesh.position.set(e.x * tileSize, 0.7, e.z * tileSize);
        mesh.metadata = { level: e.level, x: e.x, z: e.z };

        const plane = BABYLON.MeshBuilder.CreatePlane("label" + i, {size:1.5}, scene);
        plane.position.set(e.x * tileSize, 1.8, e.z * tileSize);
        plane.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_ALL;

        const label = new BABYLON.GUI.Rectangle();
        label.width = "60px";
        label.height = "30px";
        label.cornerRadius = 5;
        label.color = "white";
        label.thickness = 1;
        label.background = "red";

        const text = new BABYLON.GUI.TextBlock();
        text.text = "Lvl " + e.level;
        text.color = "white";
        label.addControl(text);

        advancedTexture.addControl(label);
        label.linkWithMesh(plane);

        mesh.actionManager = new BABYLON.ActionManager(scene);
        mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, function () {
          const path = bfsPath(playerGridPos, { x: e.x, z: e.z }, grid);
          if (path) movePlayer(path, mesh);
        }));

        return mesh;
      });

      return scene;
    }

    function bfsPath(start, goal, grid) {
      const visited = new Set();
      const queue = [{ x: start.x, z: start.z, path: [] }];

      while (queue.length > 0) {
        const { x, z, path } = queue.shift();
        const key = posKey(x, z);
        if (visited.has(key)) continue;
        visited.add(key);

        if (x === goal.x && z === goal.z) return [...path, { x, z }];

        for (const d of directions) {
          const nx = x + d.dx, nz = z + d.dz;
          if (nx >= 0 && nz >= 0 && nx < gridSize && nz < gridSize && grid[posKey(nx, nz)]) {
            queue.push({ x: nx, z: nz, path: [...path, { x, z }] });
          }
        }
      }
      return null;
    }

    function movePlayer(path, targetMesh) {
      if (!path || path.length === 0) return;
      const next = path.shift();
      playerMesh.position.set(next.x * tileSize, 0.5, next.z * tileSize);
      playerGridPos = { x: next.x, z: next.z };
      setTimeout(() => {
        if (path.length > 0) {
          movePlayer(path, targetMesh);
        } else {
          fight(targetMesh);
        }
      }, 150);
    }

    function fight(enemyMesh) {
      const level = enemyMesh.metadata.level;
      if (playerLevel >= level) {
        playerLevel += level;
        playerLevelDisplay.textContent = playerLevel;
        enemyMesh.dispose();
      } else {
        resetGame();
      }
    }

    function resetGame() {
      scene.dispose();
      playerLevel = 1;
      playerGridPos = { ...playerStart };
      playerLevelDisplay.textContent = playerLevel;
      scene = createScene();
      engine.runRenderLoop(() => scene.render());
    }

    scene = createScene();
    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
