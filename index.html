<!DOCTYPE html><html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Raster-Prototyp mit Wegfindung</title>
  <style>
    body { background: #111; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
    h1 { margin-top: 20px; }
    #grid {
      display: grid;
      grid-template-columns: repeat(32, 20px);
      grid-template-rows: repeat(32, 20px);
      gap: 1px;
      margin: 20px;
    }
    .cell {
      width: 20px;
      height: 20px;
      background-color: #2c2c2c;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
    }
    .player { background-color: limegreen; }
    .enemy { background-color: crimson; }
    .wall { background-color: #555; pointer-events: none; }
    .empty { background-color: #2c2c2c; }
  </style>
</head>
<body>
  <h1>ðŸ§  StÃ¤rke Merge Battle â€“ Prototyp mit Wegfindung</h1>
  <p>SpielerstÃ¤rke: <span id="playerLevel">1</span></p>
  <div id="grid"></div>
  <p id="message"></p>  <script>
    const gridSize = 32;
    const grid = document.getElementById('grid');
    const message = document.getElementById('message');
    const playerLevelDisplay = document.getElementById('playerLevel');

    let playerLevel = 1;
    let playerSpawn = { x: 1, y: 1 };
    let playerPosition = { ...playerSpawn };

    const enemies = [
      { x: 5, y: 1, level: 1, alive: true },
      { x: 10, y: 10, level: 2, alive: true },
      { x: 20, y: 5, level: 3, alive: true }
    ];

    const walls = [];
    for (let y = 1; y <= 8; y++) walls.push({ x: 3, y });
    for (let y = 10; y <= 20; y++) walls.push({ x: 15, y });

    function isWall(x, y) {
      return walls.some(w => w.x === x && w.y === y);
    }

    function createCell(x, y) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.x = x;
      cell.dataset.y = y;

      if (x === playerPosition.x && y === playerPosition.y) {
        cell.classList.add('player');
        cell.textContent = 'ðŸ§';
      } else {
        const enemy = enemies.find(e => e.x === x && e.y === y && e.alive);
        if (enemy) {
          cell.classList.add('enemy');
          cell.textContent = enemy.level;
          cell.addEventListener('click', () => moveTo(enemy));
        } else if (isWall(x, y)) {
          cell.classList.add('wall');
        } else {
          cell.classList.add('empty');
        }
      }

      return cell;
    }

    function renderGrid() {
      grid.innerHTML = '';
      playerLevelDisplay.textContent = playerLevel;
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          grid.appendChild(createCell(x, y));
        }
      }
    }

    function moveTo(enemy) {
      const path = findPath(playerPosition, { x: enemy.x, y: enemy.y });
      if (!path) {
        message.textContent = 'Kein Weg zum Ziel!';
        return;
      }
      followPath(path, enemy);
    }

    function followPath(path, enemy) {
      if (path.length === 0) return;
      const next = path.shift();
      playerPosition = next;
      renderGrid();
      setTimeout(() => {
        if (path.length > 0) {
          followPath(path, enemy);
        } else {
          fightEnemy(enemy);
        }
      }, 100);
    }

    function fightEnemy(enemy) {
      if (playerLevel >= enemy.level) {
        playerLevel += enemy.level;
        enemy.alive = false;
        playerPosition = { x: enemy.x, y: enemy.y };
        message.textContent = `Gegner besiegt! Neue StÃ¤rke: ${playerLevel}`;
      } else {
        message.textContent = `Zu stark! Du verlierst und startest neu.`;
        resetGame();
        return;
      }
      renderGrid();
    }

    function resetGame() {
      playerLevel = 1;
      playerPosition = { ...playerSpawn };
      enemies.forEach(e => e.alive = true);
      renderGrid();
    }

    function findPath(start, end) {
      const queue = [[start]];
      const visited = new Set();

      while (queue.length > 0) {
        const path = queue.shift();
        const { x, y } = path[path.length - 1];
        const key = `${x},${y}`;
        if (visited.has(key)) continue;
        visited.add(key);

        if (x === end.x && y === end.y) return path;

        const neighbors = [
          { x: x + 1, y },
          { x: x - 1, y },
          { x, y: y + 1 },
          { x, y: y - 1 }
        ];

        for (const n of neighbors) {
          if (
            n.x >= 0 && n.x < gridSize &&
            n.y >= 0 && n.y < gridSize &&
            !isWall(n.x, n.y)
          ) {
            queue.push([...path, n]);
          }
        }
      }
      return null;
    }

    renderGrid();
  </script></body>
</html>
